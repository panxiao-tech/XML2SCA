/**
 * This file is automatically generated using [XML2SCA] 
 * Contact : panxiao.tech@gmail.com
 * Web     : http://panxiao.tech/tools/xml2sca/
 * 
 * @file    sensor_adc_example/src/sca_tdf_adc.cpp
 * @author  Xiao Pan (pan@cs.uni-kl.de)
 * @date    10:46:05 Apr 16 2018
 * @section LICENSE License (ADD YOUR LICENSE HERE)
 *  
 * @section DESCRIPTION Description (ADD YOUR DESCRIPTION HERE)
 *          Example project of [XML2AMS]
 * 
 */


#include "sca_tdf_adc.h"

//  
//! Custom Constructor 
//  
sca_tdf_adc::sca_tdf_adc(sc_core::sc_module_name nm,
		double _vref,
		unsigned int _res,
		double _fs,
		int _rate )
{
	 // Local variables store module parameters
	 p_vref = _vref;
	 p_res = _res;
	 p_fs = _fs;
	 p_rate = _rate;

}

//  
//  @brief Software interface to set adc resolution (accepted values : 9/10/11/12 bits)
//  
bool sca_tdf_adc::set_res(unsigned int _res,bool _enable)
{
    //<<< START OF USER-ADDED-CODE >>>>
    if(_enable)
    {
        p_res = _res;
        adc_max = (long)(pow(2.0, p_res ));
        adc_lsb = p_vref / (adc_max);
    }
	return true;
    //<<< END OF USER-ADDED-CODE >>>
}

//  
//  @brief Software interface to change sampling rate 
//  
bool sca_tdf_adc::set_fs(double _fs,bool _enable)
{
    /* not implemented */
    std::cout<<  "Set ADC's Sampling Rate to "<<_fs <<std::endl ;	//
	return true;
}


//
//  @brief return maximum converted value of ADC
//
uint16_t sca_tdf_adc::max_value(uint16_t _value)
{
    //<<< START OF USER-ADDED-CODE >>>>
    if(std::fabs(_value) > adc_max-1)
        _value = _value> 0 ? adc_max-1 : -adc_max;
    return _value;
    //<<< END OF USER-ADDED-CODE >>>
}



//
// initialize()
//
void  sca_tdf_adc::initialize()
{
    //<<< START OF USER-ADDED-CODE >>>>
    adc_max = (long)(pow(2.0, p_res ));
    adc_lsb = p_vref / (adc_max);
    //<<< END OF USER-ADDED-CODE >>>
}

//
// processing()
//
void sca_tdf_adc::processing()
{
    //<<< START OF USER-ADDED-CODE >>>>
    analog = pin_pos.read() - pin_neg.read();  //  read analog input
    erg = lround(analog / adc_lsb); // calculate digital value and rounding
    erg = max_value (erg);     // output limitation
    bv_erg = erg; // save as bitvector
    pout_conv.write(bv_erg);
    //<<< END OF USER-ADDED-CODE >>>
}


